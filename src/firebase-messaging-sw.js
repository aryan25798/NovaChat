importScripts('https://storage.googleapis.com/workbox-cdn/releases/6.4.1/workbox-sw.js');

// 1. Workbox Standard Configuration
self.skipWaiting();
workbox.core.clientsClaim();
workbox.precaching.cleanupOutdatedCaches();

// Share Target Handler
self.addEventListener('fetch', (event) => {
    const url = new URL(event.request.url);
    if (event.request.method === 'POST' && url.pathname === '/share-target') {
        event.respondWith(
            (async () => {
                const formData = await event.request.formData();
                const media = formData.get('media');
                const text = formData.get('text');
                const title = formData.get('title');
                const sharedUrl = formData.get('url');

                const cache = await caches.open('share-target-cache');

                if (media) {
                    await cache.put('/api/share-media', new Response(media));
                }

                // Combine text parts
                const fullText = [title, text, sharedUrl].filter(Boolean).join('\n');

                const metadata = {
                    text: fullText,
                    hasMedia: !!media,
                    timestamp: Date.now()
                };

                await cache.put('/api/share-data', new Response(JSON.stringify(metadata)));

                return Response.redirect('/share?processing=true', 303);
            })()
        );
    }
});

// Precache all assets generated by Vite
workbox.precaching.precacheAndRoute(self.__WB_MANIFEST);

// 2. Navigation Fallback (Fix for 404 on refresh)
// Use a more robust check to ensure index.html exists in precache
const navigationHandler = async (params) => {
    try {
        // 1. Try to find index.html in the precache
        const cacheKey = workbox.precaching.getCacheKeyForURL('/index.html');
        if (cacheKey) {
            const cachedResponse = await caches.match(cacheKey);
            if (cachedResponse) return cachedResponse;
        }
    } catch (e) {
        // Ignore precache errors
    }

    // 2. Network Fallback: Try to fetch the index.html from the network
    // We fetch '/index.html' explicitly instead of the route URL to support SPA
    try {
        const networkResponse = await fetch('/index.html');
        if (networkResponse && networkResponse.ok) {
            return networkResponse;
        }
    } catch (e) {
        console.error('Network fetch for /index.html failed:', e);
    }

    // 3. Last Resort: Just fetch the request (might 404 but better than crashing)
    return fetch(params.request);
};

workbox.routing.registerRoute(
    new workbox.routing.NavigationRoute(navigationHandler)
);

// 3. Firebase Messaging Service Worker
// Import scripts from CDN as Firebase JS SDK isn't fully tree-shakable/bundled easily in SW without issues sometimes.
importScripts('https://www.gstatic.com/firebasejs/10.13.2/firebase-app-compat.js');
importScripts('https://www.gstatic.com/firebasejs/10.13.2/firebase-messaging-compat.js');
importScripts('https://www.gstatic.com/firebasejs/10.13.2/firebase-firestore-compat.js');
importScripts('https://www.gstatic.com/firebasejs/10.13.2/firebase-database-compat.js');

// Initialize the Firebase app in the service worker
const firebaseConfig = {
    apiKey: "AIzaSyDINn3KvxCX4FHQm_NG4pMsCAxeCcJeDqw",
    authDomain: "whatsappclone-50b5b.firebaseapp.com",
    projectId: "whatsappclone-50b5b",
    storageBucket: "whatsappclone-50b5b.firebasestorage.app",
    messagingSenderId: "662334343258",
    appId: "1:662334343258:web:a1b7a9fe49563c9aeaf063",
    databaseURL: "https://whatsappclone-50b5b-default-rtdb.firebaseio.com"
};

if (!firebaseConfig.apiKey) {
    console.error("Service Worker: Missing Firebase API Key! Injection failed during build.");
}

// If placeholders haven't been replaced (e.g. dev mode or build issue), 
// we try to use global replacements if provided via vite-plugin-pwa.
if (!firebaseConfig.apiKey) {
    console.warn("Service Worker missing API key. Ensure injection is working.");
}

if (firebase.apps.length === 0) {
    firebase.initializeApp(firebaseConfig);
}

// Retrieve an instance of Firebase Messaging
const messaging = firebase.messaging();

// Initialize Firestore (Compat)
const db = firebase.firestore();

messaging.onBackgroundMessage(async (payload) => {
    console.log('[firebase-messaging-sw.js] ðŸ”” Received background message ', payload);

    // BACKGROUND DELIVERY LOGIC (Double Ticks)
    // CRITICAL: Immediately signal delivery to sender
    if (payload.data) {
        const { chatId, messageId } = payload.data;
        if (chatId && messageId) {
            try {
                // 1. Update RTDB Signal (Fastest path for UI update)
                const rtdbRef = firebase.database().ref(`chats/${chatId}/messages/${messageId}`);
                rtdbRef.update({ delivered: true }).catch(err => console.warn("SW RTDB update failed", err));

                // 2. Update Firestore (Persistence)
                // Note: Firestore in SW is limited, using compat version
                const msgRef = firebase.firestore().collection('chats').doc(chatId).collection('messages').doc(messageId);
                msgRef.update({ delivered: true }).catch(err => console.warn("SW Firestore update failed", err));

                console.log('[SW] Marked delivered:', messageId);
            } catch (e) {
                console.warn('[SW] Delivery signal error:', e);
            }
        }
    }

    // Customize notification here
    const notificationTitle = payload.notification.title;
    const notificationOptions = {
        body: payload.notification.body,
        icon: '/nova-icon.png', // Updated to use the new PNG icon
        badge: '/nova-icon.png',
        tag: payload.notification.tag || 'general',
        data: payload.data || {}
    };

    return self.registration.showNotification(notificationTitle, notificationOptions);
});

// Handle Notification Click
self.addEventListener('notificationclick', function (event) {
    console.log('[firebase-messaging-sw.js] Notification click received.');
    event.notification.close();

    // Open the app or focus the window
    event.waitUntil(
        clients.matchAll({
            type: "window",
            includeUncontrolled: true
        }).then(function (clientList) {
            // Check if there's already a window open
            for (var i = 0; i < clientList.length; i++) {
                var client = clientList[i];
                // Focus if already open
                if (client.url.indexOf('/') !== -1 && 'focus' in client) {
                    return client.focus();
                }
            }
            // Otherwise open a new window
            if (clients.openWindow) {
                return clients.openWindow('/');
            }
        })
    );
});
