import { db, rtdb } from "../firebase";
import {
    collection,
    addDoc,
    onSnapshot,
    doc,
    updateDoc,
    serverTimestamp,
    query,
    where,
    getDoc,
    setDoc
} from "firebase/firestore";
import { ref, set, onValue, push, onChildAdded, remove, get, off } from "firebase/database";
import { listenerManager } from "../utils/ListenerManager";

// --- Signaling & Call Management (Hybrid: Firestore for Status/History, RTDB for Signaling) ---

export const createCallDoc = async (caller, receiver, type, chatId) => {
    // 1. Create Master Record in Firestore (Status, History)
    const callDocRef = doc(collection(db, "calls"));
    const callId = callDocRef.id;

    await setDoc(callDocRef, {
        callerId: caller.uid,
        callerName: caller.displayName,
        callerPhoto: caller.photoURL,
        receiverId: receiver.uid,
        type,
        status: 'ringing',
        timestamp: serverTimestamp(),
        chatId: chatId || null
    });

    // 2. Initialize RTDB Node with Metadata for Security Rules
    const rtdbRef = ref(rtdb, `calls/${callId}`);
    await set(rtdbRef, {
        callerId: caller.uid,
        receiverId: receiver.uid,
        timestamp: serverTimestamp()
    });

    // 3. Register Disconnect Cleanup (Safe Signaling)
    rtdb.ref(`calls/${callId}`).onDisconnect().remove();

    return callId;
};

export const updateCallStatus = async (callId, status, data = {}) => {
    const callRef = doc(db, "calls", callId);
    await updateDoc(callRef, {
        status,
        ...data
    });
};

export const addCandidate = async (callId, type, candidate) => {
    // RTDB: High frequency updates
    // type is 'caller' (my role). Target collection is 'callerCandidates' (candidates generated by caller)
    const collectionName = type === 'caller' ? 'callerCandidates' : 'calleeCandidates';
    const rtdbRef = ref(rtdb, `calls/${callId}/candidates/${collectionName}`);
    await push(rtdbRef, candidate.toJSON());
};

export const subscribeToCall = (callId, onUpdate) => {
    const listenerKey = `call-${callId}`;

    // 1. Listen to Firestore (Status changes: ringing -> connected -> ended)
    const fsUnsub = onSnapshot(doc(db, "calls", callId), (snap) => {
        if (snap.exists()) {
            onUpdate({ ...snap.data(), _source: 'fs' });
        }
    }, (error) => {
        listenerManager.handleListenerError(error, 'SubscribeToCall_FS');
    });

    // 2. Listen to RTDB (Signaling: Answer/Offer changes)
    const rtdbRef = ref(rtdb, `calls/${callId}`);
    const rtdbListener = onValue(rtdbRef, (snap) => {
        const val = snap.val();
        if (val) {
            onUpdate({ ...val, _source: 'rtdb' });
        }
    }, (error) => {
        console.warn("[CallService] RTDB Listen Error:", error);
    });

    const unsubscribe = () => {
        fsUnsub();
        off(rtdbRef, 'value', rtdbListener);
    };

    listenerManager.subscribe(listenerKey, unsubscribe);
    return () => listenerManager.unsubscribe(listenerKey);
};

export const subscribeToIncomingCalls = (userId, onCallReceived) => {
    // Incoming calls still listen to Firestore 'ringing' status
    // This maintains the 'history' aspect and avoids strict reliance on ephemeral RTDB for core notification
    const q = query(
        collection(db, "calls"),
        where("receiverId", "==", userId),
        where("status", "==", "ringing")
    );

    const listenerKey = `incoming-calls-${userId}`;
    const unsubscribe = onSnapshot(q, (snapshot) => {
        snapshot.docChanges().forEach(change => {
            if (change.type === "added") {
                onCallReceived(change.doc.id, change.doc.data());
            }
        });
    }, (error) => {
        listenerManager.handleListenerError(error, 'IncomingCalls');
    });

    listenerManager.subscribe(listenerKey, unsubscribe);
    return () => listenerManager.unsubscribe(listenerKey);
};

export const subscribeToCandidates = (callId, type, onCandidate) => {
    // Listen to the OTHER side's candidates
    // If I am 'caller', I want 'calleeCandidates'
    const collectionName = type === 'caller' ? 'calleeCandidates' : 'callerCandidates';
    const listenerKey = `candidates-${callId}-${type}`;

    const rtdbRef = ref(rtdb, `calls/${callId}/candidates/${collectionName}`);

    const listener = onChildAdded(rtdbRef, (snapshot) => {
        if (snapshot.exists()) {
            onCandidate(snapshot.val());
        }
    }, (error) => {
        console.warn("[CallService] RTDB Candidate Error:", error);
    });

    const unsubscribe = () => off(rtdbRef, 'child_added', listener);

    listenerManager.subscribe(listenerKey, unsubscribe);
    return () => listenerManager.unsubscribe(listenerKey);
};

export const setLocalDescription = async (callId, description, type) => {
    // type is 'offer' or 'answer'
    // Write SDP to RTDB for speed
    const rtdbRef = ref(rtdb, `calls/${callId}/${type}`);
    await set(rtdbRef, { type: description.type, sdp: description.sdp });
};

export const getCallDoc = async (callId) => {
    // Fetch both and merge
    const fsSnap = await getDoc(doc(db, "calls", callId));
    const fsData = fsSnap.exists() ? fsSnap.data() : {};

    const rtdbSnap = await get(ref(rtdb, `calls/${callId}`));
    const rtdbData = rtdbSnap.val() || {};

    return { ...fsData, ...rtdbData };
};

export const cleanupSignaling = async (callId) => {
    if (!callId) return;
    try {
        const rtdbRef = ref(rtdb, `calls/${callId}`);
        await remove(rtdbRef);
    } catch (e) {
        console.warn("Error cleaning up signaling:", e);
    }
};

// HELPER: Integrated Disconnect Watchdog
export const registerDisconnectCleanup = (callId) => {
    if (!callId) return;
    const rtdbRef = ref(rtdb, `calls/${callId}`);
    // This ensures if the tab crashes/closes, the RINGING and CANDIDATES are purged
    // Firestore status will still be 'missed' or 'ended' via client-side logic + triggers
    const disconnectRef = ref(rtdb, `calls/${callId}`);
    return rtdb.ref(`calls/${callId}`).onDisconnect().remove();
};
