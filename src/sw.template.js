importScripts('https://storage.googleapis.com/workbox-cdn/releases/6.4.1/workbox-sw.js');

// 1. Workbox Standard Configuration
self.skipWaiting();
workbox.core.clientsClaim();
workbox.precaching.cleanupOutdatedCaches();

// Share Target Handler
self.addEventListener('fetch', (event) => {
    const url = new URL(event.request.url);
    if (event.request.method === 'POST' && url.pathname === '/share-target') {
        event.respondWith(
            (async () => {
                const formData = await event.request.formData();
                const media = formData.get('media');
                const text = formData.get('text');
                const title = formData.get('title');
                const sharedUrl = formData.get('url');

                const cache = await caches.open('share-target-cache');

                if (media) {
                    await cache.put('/api/share-media', new Response(media));
                }

                // Combine text parts
                const fullText = [title, text, sharedUrl].filter(Boolean).join('\n');

                const metadata = {
                    text: fullText,
                    hasMedia: !!media,
                    timestamp: Date.now()
                };

                await cache.put('/api/share-data', new Response(JSON.stringify(metadata)));

                return Response.redirect('/share?processing=true', 303);
            })()
        );
    }
});

// Precache all assets generated by Vite
workbox.precaching.precacheAndRoute(self.__WB_MANIFEST);

// 2. Navigation Fallback (Fix for 404 on refresh)
// Use a more robust check to ensure index.html exists in precache
const navigationHandler = async (params) => {
    try {
        // 1. Try to find index.html in the precache
        const cacheKey = workbox.precaching.getCacheKeyForURL('/index.html');
        if (cacheKey) {
            const cachedResponse = await caches.match(cacheKey);
            if (cachedResponse) return cachedResponse;
        }
    } catch (e) {
        // Ignore precache errors
    }

    // 2. Network Fallback: Try to fetch the index.html from the network
    // We fetch '/index.html' explicitly instead of the route URL to support SPA
    try {
        const networkResponse = await fetch('/index.html');
        if (networkResponse && networkResponse.ok) {
            return networkResponse;
        }
    } catch (e) {
        console.error('Network fetch for /index.html failed:', e);
    }

    // 3. Last Resort: Just fetch the request (might 404 but better than crashing)
    return fetch(params.request);
};

workbox.routing.registerRoute(
    new workbox.routing.NavigationRoute(navigationHandler)
);

// 3. Firebase Messaging Service Worker
// Import scripts from CDN as Firebase JS SDK isn't fully tree-shakable/bundled easily in SW without issues sometimes.
importScripts('https://www.gstatic.com/firebasejs/10.13.2/firebase-app-compat.js');
importScripts('https://www.gstatic.com/firebasejs/10.13.2/firebase-messaging-compat.js');
importScripts('https://www.gstatic.com/firebasejs/10.13.2/firebase-firestore-compat.js');
importScripts('https://www.gstatic.com/firebasejs/10.13.2/firebase-database-compat.js');

// Initialize the Firebase app in the service worker
const firebaseConfig = {
    apiKey: "__VITE_FIREBASE_API_KEY__",
    authDomain: "__VITE_FIREBASE_AUTH_DOMAIN__",
    projectId: "__VITE_FIREBASE_PROJECT_ID__",
    storageBucket: "__VITE_FIREBASE_STORAGE_BUCKET__",
    messagingSenderId: "__VITE_FIREBASE_MESSAGING_SENDER_ID__",
    appId: "__VITE_FIREBASE_APP_ID__",
    databaseURL: "__VITE_FIREBASE_DATABASE_URL__"
};

if (!firebaseConfig.apiKey) {
    console.error("Service Worker: Missing Firebase API Key! Injection failed during build.");
}

// If placeholders haven't been replaced (e.g. dev mode or build issue), 
// we try to use global replacements if provided via vite-plugin-pwa.
if (!firebaseConfig.apiKey) {
    console.warn("Service Worker missing API key. Ensure injection is working.");
}

if (firebase.apps.length === 0) {
    firebase.initializeApp(firebaseConfig);
}

const messaging = firebase.messaging();

// Initialize Firestore (Compat)
const db = firebase.firestore();

messaging.onBackgroundMessage(async (payload) => {
    console.log('[firebase-messaging-sw.js] ðŸ”” Received background message ', payload);

    // BACKGROUND DELIVERY LOGIC (Double Ticks)
    if (payload.data) {
        const { chatId, messageId } = payload.data;
        if (chatId && messageId) {
            try {
                // 1. Update RTDB Signal (Fastest path for UI update)
                const rtdbRef = firebase.database().ref(`chats/${chatId}/messages/${messageId}`);
                rtdbRef.update({ delivered: true }).catch(err => console.warn("SW RTDB update failed", err));

                // 2. Update Firestore (Persistence)
                const msgRef = firebase.firestore().collection('chats').doc(chatId).collection('messages').doc(messageId);
                msgRef.update({ delivered: true }).catch(err => console.warn("SW Firestore update failed", err));

                console.log('[SW] Marked delivered:', messageId);
            } catch (e) {
                console.warn('[SW] Delivery signal error:', e);
            }
        }
    }

    // CUSTOM NOTIFICATION DISPLAY (Data-Only Message Handling)
    // Fallback to payload.notification if present (backward compat), otherwise use data
    const notificationTitle = payload.notification?.title || payload.data?.title || "New Message";
    const notificationBody = payload.notification?.body || payload.data?.body || "You have a new message";
    const notificationIcon = payload.notification?.icon || payload.data?.icon || '/nova-icon.png';
    const notificationBadge = payload.notification?.badge || payload.data?.badge || '/nova-icon.png';
    const notificationTag = payload.notification?.tag || payload.data?.tag || (payload.data?.chatId ? `chat-${payload.data.chatId}` : 'general');
    const notificationData = payload.data || {};

    const notificationOptions = {
        body: notificationBody,
        icon: notificationIcon,
        badge: notificationBadge,
        tag: notificationTag,
        data: notificationData,
        renotify: true,
        vibrate: [200, 100, 200],
        actions: [
            { action: 'open', title: 'Open' }
        ]
    };

    return self.registration.showNotification(notificationTitle, notificationOptions);
});

// Handle Notification Click
self.addEventListener('notificationclick', function (event) {
    console.log('[firebase-messaging-sw.js] Notification click received.');
    event.notification.close();

    // Open the app or focus the window
    event.waitUntil(
        clients.matchAll({
            type: "window",
            includeUncontrolled: true
        }).then(function (clientList) {
            // Check if there's already a window open
            for (var i = 0; i < clientList.length; i++) {
                var client = clientList[i];
                // Focus if already open
                if (client.url.indexOf('/') !== -1 && 'focus' in client) {
                    return client.focus();
                }
            }
            // Otherwise open a new window
            if (clients.openWindow) {
                return clients.openWindow('/');
            }
        })
    );
});
