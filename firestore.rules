rules_version = '2';
// @deployed 2026-02-10
// @version 1.0.0 (Production)
// status: ACTIVE
service cloud.firestore {
  match /databases/{database}/documents {

    // Helper Functions
    function isSignedIn() {
      return request.auth != null;
    }

    function isGod() {
      return isSignedIn() && request.auth.token.get('superAdmin', false) == true;
    }
    
    // Global Ban Check: Blocks ALL access if the user is banned.
    // OPTIMIZATION: Use custom claims instead of Firestore reads to save costs.
    function isNotBanned() {
      return isGod() || request.auth.token.get('isBanned', false) != true;
    }

    function isOwner(userId) {
      return isSignedIn() && (request.auth.uid == userId || isGod());
    }

    // Check if the user has 'isAdmin' field set to true (Token favored)
    function isAdmin() {
      return isSignedIn() && (request.auth.token.get('isAdmin', false) == true || isGod());
    }

    // Check if the user is a participant of a specific chat
    // Private chat IDs use canonical format: [uid1, uid2].sort().join('_')
    // Group chats use the participants array on the document
    function isParticipant(cid) {
      return isSignedIn() && (
        // 1. Structural: check if UID appears in the chat ID (covers private + gemini chats)
        (cid.split('_')[0] == request.auth.uid || cid.split('_')[1] == request.auth.uid) ||
        // 2. Authoritative: check participants array for group chats
        (resource != null && request.auth.uid in resource.data.get('participants', []))
      );
    }

    // Optimized Friend Check (Authoritative)
    function isFriendOf(uid) {
      return isSignedIn() && (
        uid == request.auth.uid ||
        request.auth.uid in get(/databases/$(database)/documents/users/$(uid)).data.get('friends', [])
      );
    }

    // Block Check: Enforced at write-time for sending requests/messages.
    // Checks if the TARGET has blocked the current user.
    function isNotBlocked(targetUserId) {
      return targetUserId == null || targetUserId == request.auth.uid || 
             isGod() ||
             !exists(/databases/$(database)/documents/users/$(targetUserId)) ||
             !(request.auth.uid in get(/databases/$(database)/documents/users/$(targetUserId)).data.get('blockedUsers', []));
    }

    // Helper: Check if user is a member of the chat (fetching parent doc if needed)
    function isChatMember(chatId) {
      return isSignedIn() && (
        // 1. Authoritative: Check parent doc participants
        (exists(/databases/$(database)/documents/chats/$(chatId)) && 
         request.auth.uid in get(/databases/$(database)/documents/chats/$(chatId)).data.participants) ||
        // 2. Structural fallback: allow if ID matches the user's UID (for private chats)
        isParticipant(chatId)
      );
    }

    // 1. Users Collection - SECURED
    match /users/{userId} {
      // God Mode: Full Access
      allow read, write: if isGod();
      
      // Allow discovery: Authenticated users can read other profiles to search/add them
      allow read: if isSignedIn();

      // Create: Owner only, cannot set elevated privileges
      allow create: if isOwner(userId) && 
        // For new users, they are by definition not banned yet (doc doesn't exist)
        (!request.resource.data.keys().hasAny(['isAdmin', 'superAdmin', 'isBanned']));

      // Update: Owner only, cannot change elevated privileges
      // Admin can update banned status (moderation)
      allow update: if (isOwner(userId) && 
        (resource.data.get('isBanned', false) != true) && (
          // Option A: Standard update (no restricted keys)
          (!request.resource.data.diff(resource.data).affectedKeys().hasAny(['isAdmin', 'superAdmin', 'isBanned'])) ||
          // Option B: AUTO-PATCH - Allow setting superAdmin to false ONLY if it was missing
          (request.resource.data.diff(resource.data).affectedKeys().hasOnly(['superAdmin']) && 
           resource.data.get('superAdmin', null) == null && 
           request.resource.data.superAdmin == false)
        ))
        || (isAdmin() && request.resource.data.diff(resource.data).affectedKeys().hasOnly(['isBanned']))
        // Allow user to request deletion or cancel it
        || (isOwner(userId) && request.resource.data.diff(resource.data).affectedKeys().hasOnly(['deletionRequested', 'deletionRequestedAt']));
    }

    // 1b. User Feed Subcollection - SECURED
    match /users/{userId}/feed/{docId} {
      allow read: if isOwner(userId);
      allow write: if false; // Only manageable via Cloud Functions
    }

    // 2. Recursive Messages Access (For Admin CollectionGroup Queries)
    // IMPORTANT: This must come BEFORE the chats collection to allow collectionGroup queries
    match /{path=**}/messages/{messageId} {
       allow read, update, delete: if isAdmin() || isGod();
    }

    // 3. Chats Collection
    match /chats/{chatId} {
      allow read: if (isSignedIn() && (
        (isAdmin() || isGod()) || 
        (resource == null) || 
        (request.auth.uid in resource.data.participants) ||
        isParticipant(chatId)
      )) && isNotBanned();
      
      allow create: if isSignedIn() && isNotBanned() && 
        request.auth.uid in request.resource.data.participants;
      
      allow update: if (isSignedIn() && (
         (request.auth.uid in resource.data.participants) ||
         isParticipant(chatId) || isAdmin() || isGod()
      )) && (
        // Standard updates: block protected fields unless rate-limited
        (!request.resource.data.diff(resource.data).affectedKeys().hasAny(['lastMessageTimestamp', 'participants', 'id', 'type', 'chatRole'])) ||
        (request.time > resource.data.lastMessageTimestamp + duration.value(500, 'ms') &&
         !request.resource.data.diff(resource.data).affectedKeys().hasAny(['chatRole'])) ||
        // Group admin operations: require chatRole[caller] == 'admin'
        // Allows chatRole AND/OR participants changes only if the caller is a group admin
        (resource.data.get('chatRole', {})[request.auth.uid] == 'admin' &&
         request.resource.data.diff(resource.data).affectedKeys().hasAny(['chatRole', 'participants']))
      );
      
      allow delete: if isAdmin();
      
      match /messages/{messageId} {
        allow read: if (isAdmin() || isGod() || isChatMember(chatId)) && isNotBanned();
        
        allow create: if (isChatMember(chatId) || isAdmin() || isGod()) && isNotBanned();
        
        // Update: Allow reactions, read status, OR hiding for self
        // CRITICAL: Block mutation of text, media, senderId, and isFlagged status.
        allow update: if (isChatMember(chatId) || isAdmin() || isGod()) && isNotBanned() && (
          // Allow users to add themselves to hiddenBy
          (request.resource.data.diff(resource.data).affectedKeys().hasOnly(['hiddenBy']) && 
           request.resource.data.hiddenBy.hasAll([request.auth.uid])) ||
          // Allow reactions and read delivery status only
          (request.resource.data.diff(resource.data).affectedKeys().hasOnly(['reactions', 'read', 'delivered']))
        );

        allow delete: if isAdmin();
      }
    }

    // 3. Friend Requests
    match /friend_requests/{requestId} {
      // READ: Must be sender or receiver. 
      // CRITICAL: Removed isNotBlocked from read to allow outgoing/incoming list queries.
      allow read: if isSignedIn() && (
        (resource == null) || // Allow querying for new docs
        (resource.data.from == request.auth.uid || 
         resource.data.to == request.auth.uid ||
         isAdmin() || isGod())
      ) && isNotBanned();
      
      // WRITE: Enforce blocks here
      allow create: if isSignedIn() && request.resource.data.from == request.auth.uid && 
        isNotBanned() && isNotBlocked(request.resource.data.to) && 
        !get(/databases/$(database)/documents/users/$(request.resource.data.to)).data.get('superAdmin', false);
        
      allow update, delete: if isSignedIn() && (
        resource.data.from == request.auth.uid || 
        resource.data.to == request.auth.uid || 
        isAdmin() || isGod()
      ) && isNotBanned();
    }

    // 4. Status Collection - SECURED (Friend Only via Denormalization)
    match /statuses/{statusId} {
       // Read: Only allow if owner, admin, or in the allowedUIDs list (denormalized friends)
       allow read: if isSignedIn() && (
         statusId == request.auth.uid || 
         isAdmin() || isGod() ||
         (resource != null && request.auth.uid in resource.data.get('allowedUIDs', []))
       );
       
       allow create: if isSignedIn() && request.resource.data.userId == request.auth.uid && isNotBanned();
       
       allow update: if isSignedIn() && (
         isOwner(resource.data.get('userId', statusId)) || statusId == request.auth.uid
       ) && isNotBanned();

       allow delete: if isSignedIn() && (
         isOwner(resource.data.get('userId', statusId)) || isAdmin() || isGod()
       ) && isNotBanned();

       // Subcollection for Viewers (Scalable)
       match /views/{viewId} {
         // Owner of the status can read views
         allow read: if isSignedIn() && (statusId == request.auth.uid || isAdmin() || isGod());
         
         // Friends/Viewers can create a view record
         // Note: We use 'set' with a unique ID composed of itemId_viewerId usually.
         // We allow any authenticated user to "claim" they viewed it, provided they aren't banned.
         // Stricter check would be to verify they are in 'allowedUIDs' of parent, 
         // but `get()` on parent for every view write is expensive/latency-heavy.
         // Acceptable risk: Random user marks view. UI simply filters/shows it.
         allow create: if isSignedIn() && request.resource.data.viewerId == request.auth.uid && isNotBanned();
       }
    }

    // 5. Calls (Signaling) - HARDENED
    match /calls/{callId} {
       // Allow create if authenticated and the caller is the current user
       allow create: if isSignedIn() && 
         request.resource.data.callerId == request.auth.uid && 
         isNotBanned() && isNotBlocked(request.resource.data.receiverId);
       
       // Allow read/update if participant or admin
       allow read, update: if isSignedIn() && (
         request.auth.uid == resource.data.callerId || 
         request.auth.uid == resource.data.receiverId || 
         isAdmin() || isGod()
       ) && isNotBanned();
       
       match /callerCandidates/{id} {
          allow read, write: if isSignedIn() && (
            request.auth.uid == get(/databases/$(database)/documents/calls/$(callId)).data.callerId ||
            request.auth.uid == get(/databases/$(database)/documents/calls/$(callId)).data.receiverId ||
            isAdmin() || isGod()
          ) && isNotBanned();
       }
       match /calleeCandidates/{id} {
          allow read, write: if isSignedIn() && (
            request.auth.uid == get(/databases/$(database)/documents/calls/$(callId)).data.receiverId ||
            request.auth.uid == get(/databases/$(database)/documents/calls/$(callId)).data.callerId ||
            isAdmin() || isGod()
          ) && isNotBanned();
       }
    }

    // 6. Notifications
    match /notifications/{notificationId} {
      // Only the recipient or God can read/update/delete their own notifications
      allow read, update, delete: if isSignedIn() && (resource.data.toUserId == request.auth.uid || isGod());
      
      // Anyone can create a notification if they are the sender
      allow create: if isSignedIn() && request.resource.data.fromUserId == request.auth.uid && isNotBanned();
    }
    
    // 7. Secure User Locations (Admin Only Map)
    match /user_locations/{userId} {
       // Only the owner can write their location
       allow write: if isSignedIn() && request.auth.uid == userId;
       
       // Only the owner OR Admin/God can read
       allow read: if isSignedIn() && (request.auth.uid == userId || isAdmin());
    }

    // 8. Announcements (Admin Broadcasts â€” public reads, shown on login page)
    match /announcements/{announcementId} {
       // Public: announcements are system messages visible to everyone (including login page)
       allow read: if true;
       
       // Only admins can create/update/delete announcements
       allow create, update, delete: if isAdmin();
    }
    // 9. Audit Logs (Admin Only)
    match /audit_logs/{logId} {
       allow read: if isAdmin();
       allow write: if false; // Only manageable via Cloud Functions
    }
  }
}
